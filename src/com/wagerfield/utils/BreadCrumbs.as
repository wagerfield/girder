/** * Copyright (C) 2011 by Matthew Wagerfield *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package com.wagerfield.utils{	import com.asual.swfaddress.SWFAddress;	import com.asual.swfaddress.SWFAddressEvent;		import com.wagerfield.events.BreadCrumbsEvent;	import com.wagerfield.events.StaticEventDispatcher;	import flash.utils.Dictionary;	/**	 * @author Matthew Wagerfield	 */	public class BreadCrumbs extends StaticEventDispatcher	{		public static const INDEX:String = "index";				private static var _initialised:Boolean;		private static var _swfAddress:Boolean;		private static var _repeat:Boolean;		private static var _limit:uint;		private static var _index:uint;		private static var _forwardArr:Array;		private static var _historyArr:Array;		private static var _pathDict:Dictionary;		private static var _data:XMLList;		private static var _title:String;		private static var _divider:String;		/**		 * Initialises the BreadCrumbs class.		 * 		 * @param swfAddress Specifies whether or not to use SWF Address to interact with the DOM.		 * @param repeat Specifies whether or not the History Array will neighbour identical Crumbs.		 * @param limit The limit of the History Array length.		 */		public static function init(swfAddress:Boolean = false, repeat:Boolean = false, limit:uint = 100):void		{			if (!_initialised)			{				_initialised = true;				_swfAddress = swfAddress;				_repeat = repeat;				_limit = limit;								_index = 0;								_historyArr = new Array();				_pathDict = new Dictionary();								Browser.init();			}						if (_swfAddress && Browser.available)			{								SWFAddress.addEventListener(SWFAddressEvent.EXTERNAL_CHANGE, onExternal);			}		}		private static function process(value:String):void		{			var path:String = value;			var query:String = undefined;						if(value.indexOf("?") >= 0)			{				path = value.slice(0, value.indexOf("?"));				query = value.slice(value.indexOf("?"));			}			if (path == "/")			{				path = INDEX;			}						if (_pathDict[path])			{				_pathDict[path].query = query;								addCrumb(_pathDict[path]);			}			else			{				addCrumb(new Crumb(path, undefined, query));			}		}		private static function notify():void		{			var crumb:Crumb = _historyArr[_index];						if (_swfAddress && Browser.available)			{				var value:String = crumb.path == INDEX ? "" : crumb.path;								if (crumb.title)				{					SWFAddress.setTitle(crumb.title);				}				if(crumb.query)				{					value += crumb.query;				}				SWFAddress.setValue(value);			}			dispatchStaticEvent(new BreadCrumbsEvent(BreadCrumbsEvent.CHANGE, crumb));		}								private static function onExternal(e:SWFAddressEvent):void		{			process(SWFAddress.getValue());		}								/**		 * Stores a Crumb in the Crumb Dictionary so that it can be used when deep linking with SWF Address.		 * 		 * @param crumb An instance of the Crumb class to be stored.		 */		public static function storeCrumb(crumb:Crumb):void		{			_pathDict[crumb.path] = crumb;		}		/**		 * Returns a Crumb from the Key Dictionary with the provided path Array.		 * 		 * @param path Path Array.		 */		public static function getCrumb(path:String):Crumb		{			if (_pathDict[path])			{				return _pathDict[path];			}			else			{				return null;			}		}		/**		 * Adds a Crumb to the History Array. Returns the success of this method.		 * 		 * @param crumb An instance of the Crumb class.		 */		public static function addCrumb(crumb:Crumb):Boolean		{			var success:Boolean;						if (_initialised)			{				if (_repeat || (!_repeat && (crumb != _historyArr[_index])))				{					if (_index < _historyArr.length - 1)					{						_forwardArr = _historyArr.slice(_index, _historyArr.length - 1);						_forwardArr = _forwardArr.reverse();						_historyArr = _historyArr.concat(_forwardArr);					}					_historyArr.push(crumb);										if (_historyArr.length > _limit)					{						_historyArr = _historyArr.slice(_historyArr.length - _limit, _historyArr.length);					}					_index = _historyArr.length - 1;										notify();										success = true;				}			}			return success;		}		/**		 * Parses XML data formatted to describe a Site Map.		 * 		 * @param data XMLList that defines the Site Map.		 * 		 * <site title="Title" divider=" | ">		 * 	<node id="index">		 * 		<node id="level1" title="Level 1">		 * 			<node id="level2" subtitle="Level 2">		 * 			</node>		 * 		</node>		 * 		<node id="level1" title="Level 1">		 * 		</node>		 * 		<node id="level1" title="Level 1">		 * 		</node>		 * 	</node>		 * </site>		 */		public static function parseSiteMap(data:XMLList):void		{			_data = data;			_title = data.@title || "";			_divider = data.@divider || "";						processNode(XML(data.node.(@id == INDEX)));		}		private static function processNode(node:XML):void		{			var path:String = buildPath(node);			var title:String = buildTitle(node);						storeCrumb(new Crumb(path, title));						for each (var child : XML in node.children())			{				processNode(child);			}		}		private static function buildPath(node:XML):String		{			var path:String = node.@id;						if (path != INDEX)			{				while (node.parent().@id != INDEX)				{					node = node.parent();					path = node.@id + "/" + path;				}				path = "/" + path;			}			return path;		}		private static function buildTitle(node:XML):String		{			var title:String = _title;			if (node.@subtitle != "" && node.@subtitle != "null" && node.@subtitle != undefined)			{				if (title == "")				{					title = node.@subtitle;				}				else				{					title += _divider + node.@subtitle;				}			}			if (node.@title != "" && node.@title != "null" && node.@title != undefined)			{				title = node.@title;			}			return title;		}								/** If a past history is available, the History Index is incremented backwards. Returns the success of this action. */		public static function back():Boolean		{			var success:Boolean;			if (_initialised)			{				if (_index > 0)				{					_index--;					notify();					success = true;				}			}			return success;		}		/** If a future history is available, the History Index is incremented forwards. Returns the success of this action. */		public static function forward():Boolean		{			var success:Boolean;			if (_initialised)			{				if (_index < (_historyArr.length - 1))				{					_index++;					notify();					success = true;				}			}			return success;		}		/** When using SWF Address; processes the value of the URL in the Browser. Returns the success of this action. */		public static function refresh():Boolean		{			var success:Boolean;						if (_initialised && _swfAddress)			{				process(SWFAddress.getValue());				success = true;			}			return success;		}								/**		 * Adds an Event Listener to the static EventDispatcher.		 * 		 * @param type The type of event.		 * @param listener The listener function that processes the event.		 */		public static function addEventListener(type:String = null, listener:Function = null):void		{			addStaticEventListener(type, listener);		}		/**		 * Removes an Event Listener from the static EventDispatcher.		 * 		 * @param type The type of event.		 * @param listener The listener function that processes the event.		 */		public static function removeEventListener(type:String = null, listener:Function = null):void		{			removeStaticEventListener(type, listener);		}								/** @param value Specifies whether or not to use SWF Address to interact with the DOM. */		public static function set swfAddress(value:Boolean):void		{			_swfAddress = value;		}		/** @param value Specifies whether or not the History Array will neighbour identical Crumbs. */		public static function set repeat(value:Boolean):void		{			_repeat = value;		}		/** @param value Sets the History Array length limit. */		public static function set limit(value:uint):void		{			_limit = value;		}								/** Returns the current Crumb in the History Array. */		public static function get currentCrumb():Crumb		{			return _historyArr[_index];		}		/** Returns the History Array. */		public static function get history():Array		{			return _historyArr;		}		/** Returns the History Index. */		public static function get index():uint		{			return _index;		}		/** Returns the History Array length limit. */		public static function get limit():uint		{			return _limit;		}		/** Returns whether or not the History Array will neighbour identical Crumbs. */		public static function get repeat():Boolean		{			return _repeat;		}		/** Returns whether or not to use SWF Address to interact with the DOM. */		public static function get swfAddress():Boolean		{			return _swfAddress;		}	}}