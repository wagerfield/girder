/** * Copyright (C) 2011 by Matthew Wagerfield *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package com.wagerfield.utils{	import com.wagerfield.display.ColourPalette;	import com.wagerfield.display.Slider;	import com.wagerfield.display.SuperSprite;	import com.wagerfield.display.TextBox;	import com.wagerfield.drawing.Polygon;	import com.wagerfield.events.ModMouseEvent;	import com.wagerfield.events.SliderEvent;	import flash.display.BlendMode;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.DropShadowFilter;	/**	 * @author Matthew Wagerfield	 */	public class OutputPanel extends SuperSprite	{		private const MIN_WIDTH:uint = 200;		private const MIN_HEIGHT:uint = 400;				private const FOOTER:uint = 40;		private var _tabWidth:uint = 19;		private var _tabHeight:uint = 80;		private var _tabInset:uint = 5;		private var _tabDown:Boolean = false;		private var _gripWidth:uint = 9;		private var _gripStroke:uint = 1;		private var _gripSpace:uint = 1;		private var _gripInset:uint = 8;		private var _grabPoint:int = 0;		private var _border:uint = 10;		private var _stroke:uint = 2;		private var _leading:uint = 3;		private var _outputString:String = "";		private var _titleString:String = "Output Panel - v1.47";		private var _minAlpha:Number = 0.25;		private var _maxAlpha:Number = 1;		private var _palette:uint = 0;		private var _open:Boolean;		private var _shadow:DropShadowFilter;		private var _dropShadow:Boolean;		private var _props:Object;		private var _target:Object;		private var _physics:Physics;		private var _friction:Number = 0.75;		private var _inertia:Number = 0;		private var _textProps:Object;		private var _scroll:Boolean;		private var _main:Sprite;		private var _panel:Sprite;		private var _outputMask:Sprite;		private var _outputCont:Sprite;		private var _output:TextBox;		private var _index:TextBox;		private var _outputBg:Sprite;		private var _body:Sprite;		private var _footer:Sprite;		private var _toggle:Sprite;		private var _inArrow:Sprite;		private var _outArrow:Sprite;		private var _tab:Sprite;		private var _title:TextBox;		private var _panelSlider:Slider;		private var _alphaCont:Sprite;		private var _alphaSlider:Slider;		private var _alphaGuage:Shape;		/**		 * Creates an OutputPanel for displaying text traces during runtime.		 * 		 * @param width Initial width of the OutputPanel.		 * @param height Initial height of the OutputPanel.		 * @param open Opens or closes the OutputPanel.		 * @param dropShadow Specifies whether or not to apply a DropShadowFilter to the OutputPanel.		 */		public function OutputPanel(width:uint = 300, height:uint = 600, open:Boolean = true, palette:uint = ColourPalette.SLATE, dropShadow:Boolean = true):void		{			_width = width < MIN_WIDTH ? MIN_WIDTH : width;			_height = height < MIN_HEIGHT ? MIN_HEIGHT : height;			_open = open;			_palette = palette;			_dropShadow = dropShadow;			createClasses();			configClasses();			configDisplay();			addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			addEvents();			addChildren();		}		private function createClasses():void		{			_textProps = {font:"Arial", size:12, height:0, leadOffset:-6, xOffset:-3, yOffset:-5, widthOffset:1, heightOffset:-1, blendMode:BlendMode.LAYER};			_target = {x:0, width:_width};			_props = {x:0, width:_width};			_physics = new Physics(_props);			_shadow = new DropShadowFilter();			_main = new Sprite();			_panel = new Sprite();			_outputMask = new Sprite();			_outputCont = new Sprite();			_title = new TextBox();			_output = new TextBox();			_index = new TextBox();			_outputBg = new Sprite();			_body = new Sprite();			_footer = new Sprite();			_tab = new Sprite();			_toggle = new Sprite();			_inArrow = new Sprite();			_outArrow = new Sprite();			_panelSlider = new Slider(true);			_alphaCont = new Sprite();			_alphaSlider = new Slider(false);			_alphaGuage = new Shape();		}		private function configClasses():void		{			_outputCont.mask = _outputMask;			_index.horizontalLock = TextBox.LOCK_LIMITS;			_index.verticalLock = TextBox.LOCK_LIMITS;			_index.blendMode = _textProps.blendMode;			_index.textFormat.font = _textProps.font;			_index.textFormat.size = _textProps.size;			_index.xOffset = _textProps.xOffset;			_index.yOffset = _textProps.yOffset;			_index.widthOffset = _textProps.widthOffset;			_index.heightOffset = _textProps.heightOffset;			_index.text = "001";			_output.horizontalLock = TextBox.LOCK_LIMITS;			_output.verticalLock = TextBox.LOCK_LIMITS;			_output.blendMode = _textProps.blendMode;			_output.textFormat.font = _textProps.font;			_output.textFormat.size = _textProps.size;			_output.xOffset = _textProps.xOffset;			_output.yOffset = _textProps.yOffset;			_output.widthOffset = _textProps.widthOffset;			_output.heightOffset = _textProps.heightOffset;			_output.selectable = true;			_title.horizontalLock = TextBox.LOCK_LIMITS;			_title.verticalLock = TextBox.LOCK_LIMITS;			_title.blendMode = _textProps.blendMode;			_title.textFormat.font = _textProps.font;			_title.textFormat.size = 14;			_title.xOffset = -3;			_title.yOffset = -5;			_title.widthOffset = 1;			_title.heightOffset = -1;			_title.maskText = true;			_textProps.height = _index.height;			_tab.buttonMode = true;			_toggle.buttonMode = true;			_panelSlider.handleSize = 100;			_alphaSlider.ratio = 1;			_alphaSlider.handleSize = 0;			_alphaSlider.alpha = 0;			_shadow.alpha = 1;			_shadow.angle = 0;			_shadow.blurX = 3.5;			_shadow.blurY = 3.5;			_shadow.color = 0;			_shadow.distance = 0;			_shadow.quality = 2;			_shadow.strength = 1.5;		}		protected override function configDisplay():void		{			updateProperty(_index.textFormat, "color", ColourPalette.colourD(_palette));			updateProperty(_output.textFormat, "color", ColourPalette.colourE(_palette));			updateProperty(_title.textFormat, "color", ColourPalette.colourE(_palette));			updateProperty(_main, "x", _open ? 0 : _border * 2 + _stroke - _width);			updateProperty(_title, "text", _titleString);			updateProperty(_title, "padding", _border);			updateProperty(_index.textFormat, "leading", _textProps.leadOffset + _leading * 2);			updateProperty(_index, "verticalPad", _leading);			updateProperty(_index, "horizontalPad", _border);			var autoScroll:Boolean = updateProperty(_output, "text", _outputString);			updateProperty(_output.textFormat, "leading", _textProps.leadOffset + _leading * 2);			updateProperty(_output, "verticalPad", _leading);			updateProperty(_panel, "x", _border);			updateProperty(_panel, "y", _title.height);			updateProperty(_alphaCont, "x", _width - _border * 2 - _stroke);			updateProperty(_alphaCont, "y", _border);			updateProperty(_alphaSlider, "hotspotBorder", _border);			updateProperty(_alphaSlider, "width", _width - _title.width - _border * 2 - _stroke);			updateProperty(_alphaSlider, "height", _title.height - _border * 2);			updateProperty(_alphaSlider, "x", -_alphaSlider.width);			_scroll = _output.height > _outputMask.height ? true : false;			drawGraphics();			updateProperty(_title, "fieldWidth", _outputMask.width);			updateProperty(_index, "text", indexText);			updateProperty(_index, "fieldHeight", _outputBg.height);			updateProperty(_output, "x", _index.width);			updateProperty(_output, "fieldWidth", _outputMask.width - _index.width);			updateProperty(_output, "fieldHeight", _outputBg.height);			_body.filters = _dropShadow ? [_shadow] : null;			updateProperty(_footer, "y", _height - FOOTER);			updateProperty(_toggle, "x", _width - _toggle.width);			updateProperty(_inArrow, "x", _toggle.width * 0.5);			updateProperty(_inArrow, "y", _toggle.height * 0.35);			updateProperty(_inArrow, "rotation", 180);			updateProperty(_outArrow, "x", _toggle.width * 0.5);			updateProperty(_outArrow, "y", _toggle.height * 0.65);			updateProperty(_tab, "x", _width);			updateProperty(_tab, "y", (_height - _tabHeight) * 0.5);			updateProperty(_panelSlider, "x", _width - _border - _stroke);			updateProperty(_panelSlider, "y", _title.height);			updateProperty(_panelSlider, "hotspotBorder", _border);			updateProperty(_panelSlider, "width", _stroke);			updateProperty(_panelSlider, "height", _height - _title.height - FOOTER - _border);			updateProperty(_panelSlider, "handleColour", ColourPalette.colourE(_palette));			updateProperty(_panelSlider, "bgColour", ColourPalette.colourA(_palette));			updateProperty(_panelSlider, "handleSize", _scroll ? (_outputMask.height / _outputBg.height) * _panelSlider.height : 0);			updateProperty(_panelSlider, "increments", Math.ceil(_panelSlider.height / _panelSlider.handleSize));			updateProperty(_panelSlider, "enabled", _scroll);			if (autoScroll && _scroll) _panelSlider.ratio = 1;			super.configDisplay();		}		private function drawGraphics():void		{			var i:uint = 0;			var tabBorder:uint = (_height - _tabHeight) * 0.5;			with (_outputMask.graphics)			{				clear();				beginFill(0xFF0000, 0.5);				drawRect(0, 0, _width - _border * 3 - _stroke, _height - _title.height - FOOTER - _border);				endFill();			}			with (_outputBg.graphics)			{				clear();				for (i = 0; i < lineCount; i++)				{					var odd:Boolean = i % 2 == 0;					beginFill(odd ? ColourPalette.colourB(_palette) : ColourPalette.colourC(_palette));					drawRect(0, i * (_textProps.height + _leading * 2), _outputMask.width, _textProps.height + _leading * 2);					endFill();				}			}			with (_body.graphics)			{				clear();				beginFill(ColourPalette.colourC(_palette));				lineTo(_width, 0);				lineTo(_width, tabBorder);				lineTo(_width + _tabWidth, tabBorder + _tabInset);				lineTo(_width + _tabWidth, tabBorder + _tabHeight - _tabInset);				lineTo(_width, tabBorder + _tabHeight);				lineTo(_width, _height);				lineTo(0, _height);				lineTo(0, 0);				drawRect(_panel.x, _panel.y, _outputMask.width, _outputMask.height);				endFill();			}			with (_tab.graphics)			{				clear();				beginFill(0xFF0000, 0);				lineTo(_tabWidth, _tabInset);				lineTo(_tabWidth, _tabHeight - _tabInset);				lineTo(0, _tabHeight);				lineTo(0, 0);				endFill();				for (i = 0; i < _gripWidth / (_gripStroke + _gripSpace); i++)				{					beginFill(ColourPalette.colourB(_palette));					drawRect(i * (_gripStroke + _gripSpace), _tabInset + _gripInset, _gripStroke, _tabHeight - _tabInset * 2 - _gripInset * 2);					endFill();				}			}			with (_toggle.graphics)			{				clear();				beginFill(0xFF0000, 0);				drawRect(0, 0, _border * 2 + _stroke, _title.height);				endFill();			}			with (_footer.graphics)			{				clear();				beginFill(ColourPalette.colourB(_palette));				drawRect(0, 0, _width, FOOTER);				endFill();			}			with (_alphaGuage.graphics)			{				clear();				for (i = 0; i < _alphaSlider.width / (_stroke * 2); i++)				{					var posX:uint = i * _stroke * -2 - _stroke;					var on:Boolean = (_alphaSlider.handlePosition - _alphaSlider.width) >= posX;										beginFill(on ? ColourPalette.colourE(_palette) : ColourPalette.colourA(_palette));					drawRect(posX, 0, _stroke, _title.height - _border * 2);					endFill();				}			}			drawArrow(_inArrow, _open ? ColourPalette.colourE(_palette) : ColourPalette.colourA(_palette));			drawArrow(_outArrow, _open ? ColourPalette.colourA(_palette) : ColourPalette.colourE(_palette));		}		private function drawArrow(arrow:Sprite, colour:uint):void		{			with (arrow.graphics)			{				clear();				beginFill(colour);				Polygon.draw(arrow, -1.5, 0, 5, 3);				endFill();			}		}		private function addEvents():void		{			_panelSlider.addEventListener(SliderEvent.CHANGE, onSliderChange);			_alphaSlider.addEventListener(SliderEvent.CHANGE, onSliderChange);			_main.addEventListener(ModMouseEvent.MOUSE_WHEEL, onMouseWheel);			_toggle.addEventListener(ModMouseEvent.CLICK, onMouseClick);			_tab.addEventListener(ModMouseEvent.MOUSE_DOWN, onMouseDown);			stage.addEventListener(ModMouseEvent.MOUSE_UP, onMouseUp);		}		private function addChildren():void		{			addChild(_main);			_main.addChild(_panel);			_panel.addChild(_outputCont);			_outputCont.addChild(_outputBg);			_outputCont.addChild(_index);			_outputCont.addChild(_output);			_panel.addChild(_outputMask);			_main.addChild(_body);			_body.addChild(_title);			_body.addChild(_alphaCont);			_alphaCont.addChild(_alphaSlider);			_alphaCont.addChild(_alphaGuage);			_body.addChild(_toggle);			_toggle.addChild(_inArrow);			_toggle.addChild(_outArrow);			_body.addChild(_panelSlider);			_body.addChild(_tab);			_body.addChild(_footer);		}								private function onMouseClick(e:ModMouseEvent):void		{			switch (e.currentTarget)			{				case _toggle:					open = !open;					break;			}		}		private function onMouseWheel(e:ModMouseEvent):void		{			if (e.delta > 0)			{				_panelSlider.incUp();			}			else			{				_panelSlider.incDown();			}		}		private function onMouseDown(e:ModMouseEvent):void		{			if (_open)			{				_grabPoint = _tab.mouseX;				_props.width = _width;				_target.width = _width;				_tabDown = true;				this.paint = true;			}		}		private function onMouseUp(e:ModMouseEvent):void		{			if (_tabDown)			{				_tabDown = false;			}		}		private function onPaint(e:Event):void		{			if (_tabDown)			{				_target.width = (_main.mouseX - _grabPoint) < MIN_WIDTH ? MIN_WIDTH : (_main.mouseX - _grabPoint);			}			_physics.chase(_target, _friction, _inertia);			this.width = _props.width;			if (MathHelper.round(_width, _target.width, 2) && !_tabDown)			{				this.paint = false;			}		}		private function onSliderChange(e:SliderEvent):void		{			switch (e.currentTarget)			{				case _panelSlider:					_outputCont.y = Math.round((_outputBg.height - _outputMask.height) * -_panelSlider.ratio);					break;				case _alphaSlider:					_main.alpha = _minAlpha + (_maxAlpha - _minAlpha) * _alphaSlider.ratio;					drawGraphics();					break;			}		}					private function get lineCount():uint		{			var refHeight:uint = _scroll ? _output.height : _outputMask.height;			var lineCount:uint = Math.ceil(refHeight / (_textProps.height + _leading * 2));			return lineCount;		}		private function get indexText():String		{			var indexText:String = "";			for (var i:uint = 0; i < lineCount; i++)			{				indexText = indexText.concat(MathHelper.fixedNumber(i + 1, String(lineCount).length > 3 ? String(lineCount).length : 3) + "\n");			}			return indexText;		}								/** Clears the output pane. */		public function clearOutput():void		{			_outputString = "";			configDisplay();		}		/** Adds the specified text to the output pane. */		public function output(text:String, autoReturn:Boolean = true, concat:Boolean = true):void		{			_outputString = concat ? autoReturn ? _outputString != "" ? _outputString.concat("\n" + text) : text : _outputString.concat(text) : text;			configDisplay();		}								/** @param value Enables and disables the paint function that redraws and updates the OutputPanel. */		public function set paint(value:Boolean):void		{			if (value)			{				stage.addEventListener(Event.ENTER_FRAME, onPaint);			}			else			{				stage.removeEventListener(Event.ENTER_FRAME, onPaint);			}		}		/** @param value Opens and closes the OutputPanel. */		public function set open(value:Boolean):void		{			_open = value;			configDisplay();		}		/** @param value Sets the title text of the OutputPanel. */		public function set title(value:String):void		{			_titleString = value;			configDisplay();		}		/** @param value Sets the ColourPalette of the OutputPanel. */		public function set palette(value:uint):void		{			_palette = value;			configDisplay();		}		/** @param value Specifies whether or not to apply a DropShadowFilter to the OutputPanel. */		public function set dropShadow(value:Boolean):void		{			_dropShadow = value;			configDisplay();		}					/** Returns whether or not the OutputPanel is open. */		public function get open():Boolean		{			return _open;		}		/** Returns whether or not the OutputPanel is using a DropShadowFilter on the inner output pane. */		public function get dropShadow():Boolean		{			return _dropShadow;		}	}}