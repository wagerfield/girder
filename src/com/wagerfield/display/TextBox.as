/** * Copyright (C) 2011 by Matthew Wagerfield *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package com.wagerfield.display{	import com.wagerfield.events.ModMouseEvent;	import com.wagerfield.events.TextBoxEvent;	import flash.display.Shape;	import flash.display.Sprite;	import flash.system.System;	import flash.text.AntiAliasType;	import flash.text.Font;	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;	/**	 * @author Matthew Wagerfield	 */	public class TextBox extends SuperSprite	{		public static const LOCK_FIELD:String = "LockField";		public static const LOCK_LIMITS:String = "LockLimits";				private var _fieldWidth:int = 200;		private var _fieldHeight:int = 100;		private var _scale:Number = 1;		private var _xOffset:int = 0;		private var _yOffset:int = 0;		private var _widthOffset:int = 0;		private var _heightOffset:int = 0;		private var _horizontalLock:String = "";		private var _verticalLock:String = "";		private var _horizontalLimits:Boolean = false;		private var _verticalLimits:Boolean = false;		private var _leftPad:int = 0;		private var _rightPad:int = 0;		private var _topPad:int = 0;		private var _bottomPad:int = 0;		private var _showBox:Boolean = false;		private var _boxColour:int = 0xDDDDDD;		private var _boxAlpha:Number = 1;		private var _showLimits:Boolean = false;		private var _limitsColour:int = 0xFF0000;		private var _limitsAlpha:Number = 1;		private var _limitsThickness:int = 1;		private var _limitsWidth:int = 0;		private var _limitsHeight:int = 0;		private var _limitsSize:int = 10;		private var _multiLine:Boolean = true;		private var _wordWrap:Boolean = true;		private var _embedFonts:Boolean = false;		private var _selectable:Boolean = false;		private var _input:Boolean = false;		private var _maskText:Boolean = false;		private var _htmlText:String = "<p>This is an instance of the TextBox class<br/>...in HTML mode.</p>";		private var _standardText:String = "This is an instance of the TextBox class\n...in STANDARD mode.";		private var _antiAlias:Boolean = false;		private var _thickness:int = 0;		private var _sharpness:int = 0;		private var _htmlMode:Boolean;		private var _autoExpand:Boolean;		private var _box:Sprite;		private var _mask:Shape;		private var _limits:Sprite;		private var _tlCross:Shape;		private var _trCross:Shape;		private var _blCross:Shape;		private var _brCross:Shape;		private var _textFormat:TextFormat;		private var _styleSheet:StyleSheet;		private var _text:TextField;		/**		 * Registers a Font.		 * 		 * @param fontClass The Font Class.		 */		public static function registerFont(fontClass:Class):void		{			Font.registerFont(fontClass);		}		/** Returns an array of all the registered Font Classes. */		public static function get registeredFonts():Array		{			return Font.enumerateFonts(false);		}		/** Returns an array of all the registered Font names. */		public static function get registeredFontNames():Array		{			var fontNames:Array = [];			for (var i:int = 0; i < registeredFonts.length; i++)			{				var exists:Boolean = false;				for (var j:int = 0; j < fontNames.length; j++)				{					if (Font(registeredFonts[i]).fontName == fontNames[j]) exists = true;				}				if (!exists) fontNames.push(Font(registeredFonts[i]).fontName);			}			return fontNames;		}								/**		 * Creates an instance of the TextBox class for handling all types of TextField manipulation.		 * 		 * @param htmlMode If set to true, HTML mode uses a StyleSheet to format the TextField. If set to false, STANDARD mode uses a TextFormat object to format the TextField. 		 * @param bmcMode Automatically renders the text block to a BitmapClone. However, any subsequent selection or interaction with the TextField is not possible.		 * @param autoExpand Automatically updates the height of the TextField if the text exceeds the specified fieldHeight variable.		 * @param padMethod Specifies the boundary for the Box to pad.		 */		public function TextBox(htmlMode:Boolean = false, bmcMode:Boolean = false, autoExpand:Boolean = false, horizontalLock:String = TextBox.LOCK_FIELD, verticalLock:String = TextBox.LOCK_FIELD):void		{			_htmlMode = htmlMode;			_autoExpand = autoExpand;			_horizontalLock = horizontalLock;			_verticalLock = verticalLock;			createClasses();			configClasses();			configDisplay();			drawGraphics();			addEvents();			addChildren();			this.bmcMode = bmcMode;		}		private function createClasses():void		{			_box = new Sprite();			_limits = new Sprite();			_tlCross = new Shape();			_trCross = new Shape();			_blCross = new Shape();			_brCross = new Shape();			_mask = new Shape();			_text = new TextField();			_textFormat = new TextFormat();			_styleSheet = new StyleSheet();		}		private function configClasses():void		{			_text.autoSize = TextFieldAutoSize.NONE;			_text.condenseWhite = true;			_textFormat.font = "Arial";		}		protected override function configDisplay():void		{			var size:Number = 0;						if (_htmlMode)			{								var styleNames:Array = _styleSheet.styleNames;				var searchA:String;				var searchB:String;									for (var i:uint = 0; i < styleNames.length; i++)				{										var styleName:String = styleNames[i];					var style:Object = _styleSheet.getStyle(styleName);										if (styleName.charAt(0) == ".")					{						searchA = "='" + styleName.substring(1);						searchB = '="' + styleName.substring(1);					}					else					{						searchA = "<" + styleName;						searchB = "<" + styleName;					}										if (_htmlText.search(searchA) != -1 || _htmlText.search(searchB) != -1)					{												if (style.hasOwnProperty("fontSize"))						{														if (style.fontSize > 100)							{								size = Math.max(size, style.fontSize);																style.fontSize = 100;																_styleSheet.setStyle(styleName, style);							}													}					}				}				var fontTags:Array = _htmlText.match(/<font[a-zA-Z0-9_\^\$\.\|\{\[\}\]\(\)\*\+\?\\~`!@#%&-=;:'",\n\s]*>/g);								if (fontTags.length)				{										for (i = 0; i < fontTags.length; i++)					{						var tag:String = fontTags[i];						var sizeSearch:String = "size=";						var sizeIndex:int = tag.search(sizeSearch);						var prefix:String = tag.substring(0, sizeIndex + sizeSearch.length + 1);						var remainder:String = tag.substring(sizeIndex + sizeSearch.length + 1);						var sizeValue:String = remainder.substring(0, remainder.search(/['"]/));						var affix:String = remainder.substring(remainder.search(/['"]/));												if (Number(sizeValue) > 100)						{							size = Math.max(size, Number(sizeValue));																					_htmlText = _htmlText.replace(tag, prefix + 100 + affix);						}											}				}					_text.styleSheet = _styleSheet;				_text.htmlText = _htmlText;			}			else			{				size = Number(_textFormat.size);								if (size > 100)				{					_textFormat.size = 100;				}								_text.styleSheet = null;				_text.text = _standardText;				_text.setTextFormat(_textFormat);			}			if (size > 100)			{				_scale = size * 0.01;				_text.scaleX = _scale;				_text.scaleY = _scale;			}			_text.x = _xOffset + _leftPad;			_text.y = _yOffset + _topPad;			_text.width = _fieldWidth - _xOffset + _widthOffset;			_text.height = _fieldHeight - _yOffset + _heightOffset;			_limitsWidth = _xOffset + _text.textWidth * _scale + _widthOffset;			_limitsHeight = _yOffset + _text.textHeight * _scale + _heightOffset;			_horizontalLimits = _horizontalLock == TextBox.LOCK_LIMITS;			_verticalLimits = _verticalLock == TextBox.LOCK_LIMITS;			if (_limitsHeight > _fieldHeight)			{				dispatchEvent(new TextBoxEvent(TextBoxEvent.OVERFLOW, _limitsHeight - _fieldHeight));				if (_autoExpand)				{					_fieldHeight = _limitsHeight;					dispatchEvent(new TextBoxEvent(TextBoxEvent.AUTO_EXPAND));				}			}			_width = _horizontalLimits ? _limitsWidth : _fieldWidth + _widthOffset;			_width += _leftPad + _rightPad;			_height = _verticalLimits ? _limitsHeight : _fieldHeight + _heightOffset;			_height += _topPad + _bottomPad;			_mask.visible = _maskText;			_text.mask = _maskText ? _mask : null;			_text.multiline = _multiLine;			_text.wordWrap = _wordWrap;			_text.selectable = _selectable;			_text.type = _input ? TextFieldType.INPUT : TextFieldType.DYNAMIC;			_text.embedFonts = _embedFonts;			_text.antiAliasType = _antiAlias ? AntiAliasType.ADVANCED : AntiAliasType.NORMAL;			_limits.visible = _showLimits;			_limits.x = _leftPad;			_limits.y = _topPad;			_tlCross.x = 0;			_tlCross.y = 0;			_trCross.x = _limitsWidth;			_trCross.y = 0;			_blCross.x = 0;			_blCross.y = _limitsHeight;			_brCross.x = _limitsWidth;			_brCross.y = _limitsHeight;			if (_antiAlias)			{				_text.thickness = _thickness;				_text.sharpness = _sharpness;			}			drawGraphics();			super.configDisplay();		}		private function drawGraphics():void		{			with (_box.graphics)			{				clear();				beginFill(_boxColour, _showBox ? _boxAlpha : 0);				drawRect(0, 0, _width, _height);				endFill();			}			with (_tlCross.graphics)			{				clear();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsThickness - _limitsSize / 2, -_limitsThickness, _limitsSize + _limitsThickness, _limitsThickness);				endFill();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsThickness, -_limitsThickness - _limitsSize / 2, _limitsThickness, _limitsSize + _limitsThickness);				endFill();			}			with (_trCross.graphics)			{				clear();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsSize / 2, -_limitsThickness, _limitsSize + _limitsThickness, _limitsThickness);				endFill();				beginFill(_limitsColour, _limitsAlpha);				drawRect(0, -_limitsThickness - _limitsSize / 2, _limitsThickness, _limitsSize + _limitsThickness);				endFill();			}			with (_blCross.graphics)			{				clear();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsThickness - _limitsSize / 2, 0, _limitsSize + _limitsThickness, _limitsThickness);				endFill();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsThickness, -_limitsSize / 2, _limitsThickness, _limitsSize + _limitsThickness);				endFill();			}			with (_brCross.graphics)			{				clear();				beginFill(_limitsColour, _limitsAlpha);				drawRect(-_limitsSize / 2, 0, _limitsSize + _limitsThickness, _limitsThickness);				endFill();				beginFill(_limitsColour, _limitsAlpha);				drawRect(0, -_limitsSize / 2, _limitsThickness, _limitsSize + _limitsThickness);				endFill();			}			with (_mask.graphics)			{				clear();				beginFill(0xFF0000, 0.5);				drawRect(0, 0, _box.width, _box.height);				endFill();			}		}		private function addEvents():void		{			_box.addEventListener(ModMouseEvent.MOUSE_OVER, onMouseOver);			_box.addEventListener(ModMouseEvent.MOUSE_OUT, onMouseOut);		}		private function addChildren():void		{			addBitmapChild(_box);			addBitmapChild(_text);			addBitmapChild(_mask);			addChild(_limits);			_limits.addChild(_tlCross);			_limits.addChild(_trCross);			_limits.addChild(_blCross);			_limits.addChild(_brCross);		}								private function onMouseOver(e:ModMouseEvent):void		{			if (_selectable) ModMouseEvent.cursorVisible = false;		}		private function onMouseOut(e:ModMouseEvent):void		{			if (_selectable) ModMouseEvent.cursorVisible = true;		}								/** Copys the current text in the TextField to the systems clipboard. */		public function copyToClipboard():void		{			System.setClipboard(formattedText);		}								/** @param value Sets the mode of the TextBox instance to either HTML or STANDARD mode. */		public function set htmlMode(value:Boolean):void		{			_htmlMode = value;			configDisplay();		}		/** @param value Automatically vertically resizes the TextField to accomodate more text. */		public function set autoExpand(value:Boolean):void		{			_autoExpand = value;			configDisplay();		}		/** @param value Sets the width of the TextField. */		public function set fieldWidth(value:int):void		{			_fieldWidth = value;			configDisplay();		}		/** @param value Sets the height of the TextField. */		public function set fieldHeight(value:int):void		{			_fieldHeight = value;			configDisplay();		}		/** @param value Sets the x offset of the TextField from the internal origin. */		public function set xOffset(value:int):void		{			_xOffset = value;			configDisplay();		}		/** @param value Sets the y offset of the TextField from the internal origin. */		public function set yOffset(value:int):void		{			_yOffset = value;			configDisplay();		}		/** @param value Sets the width offset of the TextField in relation to the xOffset and fieldWidth. */		public function set widthOffset(value:int):void		{			_widthOffset = value;			configDisplay();		}		/** @param value Sets the height offset of the TextField in relation to the yOffset and the fieldHeight. */		public function set heightOffset(value:int):void		{			_heightOffset = value;			configDisplay();		}		/** @param value Sets the horizontal lock method. */		public function set horizontalLock(value:String):void		{			_horizontalLock = value;			configDisplay();		}		/** @param value Sets the vertical lock method. */		public function set verticalLock(value:String):void		{			_verticalLock = value;			configDisplay();		}		/** @param value Sets all the pads around the perimeter TextField. */		public function set padding(value:int):void		{			_leftPad = _rightPad = _topPad = _bottomPad = value;			configDisplay();		}		/** @param value Sets the top and bottom pads of the TextField in relation to the yOffset. */		public function set verticalPad(value:int):void		{			_topPad = _bottomPad = value;			configDisplay();		}		/** @param value Sets the left and right pads of the TextField in relation to the xOffset. */		public function set horizontalPad(value:int):void		{			_leftPad = _rightPad = value;			configDisplay();		}		/** @param value Sets the left pad of the TextField in relation to the xOffset. */		public function set leftPad(value:int):void		{			_leftPad = value;			configDisplay();		}		/** @param value Sets the right pad of the TextField in relation to the xOffset. */		public function set rightPad(value:int):void		{			_rightPad = value;			configDisplay();		}		/** @param value Sets the top pad of the TextField in relation to the yOffset. */		public function set topPad(value:int):void		{			_topPad = value;			configDisplay();		}		/** @param value Sets the bottom pad of the TextField in relation to the yOffset. */		public function set bottomPad(value:int):void		{			_bottomPad = value;			configDisplay();		}		/** @param value Specifies whether or not to embed Fonts for anti-aliasing purposes. */		public function set embedFonts(value:Boolean):void		{			_embedFonts = value;			configDisplay();		}		/** @param value Specifies whether or not the text can be selected. If set to true, the ModMouseEvent cursor is set to false when rolling over the TextBox box */		public function set selectable(value:Boolean):void		{			_selectable = value;			configDisplay();		}		/** @param value Specifies whether the TextField.type is set to INPUT or DYNAMIC */		public function set input(value:Boolean):void		{			_input = value;			configDisplay();		}		/** @param value Specifies whether or not to mask the TextField within the box excluding any padding. */		public function set maskText(value:Boolean):void		{			_maskText = value;			configDisplay();		}		/** @param value Specifies whether or not the TextField has multiple lines of text. */		public function set multiLine(value:Boolean):void		{			_multiLine = value;			configDisplay();		}		/** @param value Specifies whether or not the text is wrapped within the TextField. */		public function set wordWrap(value:Boolean):void		{			_wordWrap = value;			configDisplay();		}		/** @param value Sets the StyleSheet for the TextField when the TextBox instance is set to HTML mode. */		public function set styleSheet(value:StyleSheet):void		{			_styleSheet = value;			configDisplay();		}		/** @param value Sets the TextFormat for the TextField when the TextBox instance is set to STANDARD mode. */		public function set textFormat(value:TextFormat):void		{			_textFormat = value;			configDisplay();		}		/** @param value Sets the htmlText of the TextField when the TextBox instance is set to HTML mode. */		public function set htmlText(value:String):void		{			_htmlText = value;			configDisplay();		}		/** @param value Sets the text of the TextField when the TextBox instance is set to STANDARD mode. */		public function set text(value:String):void		{			_standardText = value;			configDisplay();		}		/** @param value Specifies whether or not to use advance anti-aliasing when rendering the Font. This can only take effect if embedFonts is set to true. */		public function set antiAlias(value:Boolean):void		{			_antiAlias = value;			configDisplay();		}		/** @param value Sets the thickness of the rendered text. */		public function set thickness(value:int):void		{			_thickness = value;			configDisplay();		}		/** @param value Sets the sharpness of the rendered text. */		public function set sharpness(value:int):void		{			_sharpness = value;			configDisplay();		}		/** @param value Specifies whether or not to show the box. */		public function set showBox(value:Boolean):void		{			_showBox = value;			configDisplay();		}		/** @param value Sets the colour value of the box. */		public function set boxColour(value:int):void		{			_boxColour = value;			configDisplay();		}		/** @param value Sets the alpha value of the box. */		public function set boxAlpha(value:Number):void		{			_boxAlpha = value;			configDisplay();		}		/** @param value Specifies whether or not to show the text height limits. */		public function set showLimits(value:Boolean):void		{			_showLimits = value;			configDisplay();		}		/** @param value Sets the colour value of the limits. */		public function set limitsColour(value:int):void		{			_limitsColour = value;			configDisplay();		}		/** @param value Sets the alpha value of the limits. */		public function set limitsAlpha(value:Number):void		{			_limitsAlpha = value;			configDisplay();		}		/** @param value Sets the thickness of the limits visual aid. */		public function set limitsThickness(value:int):void		{			_limitsThickness = value;			configDisplay();		}		/** @param value Sets the length of the limits visual aid. */		public function set limitsSize(value:int):void		{			_limitsSize = value;			configDisplay();		}								/** Returns the current mode of the TextBox instance. */		public function get htmlMode():Boolean		{			return _htmlMode;		}		/** Returns the expand mode of the TextBox instance. */		public function get autoExpand():Boolean		{			return _autoExpand;		}		/** Returns the width of the TextField instance. */		public function get fieldWidth():int		{			return _fieldWidth;		}		/** Returns the height of the TextField instance. */		public function get fieldHeight():int		{			return _fieldHeight;		}		/** Returns the x offset of the TextField with reference to the internal origin. */		public function get xOffset():int		{			return _xOffset;		}		/** Returns the y offset of the TextField with reference to the internal origin. */		public function get yOffset():int		{			return _yOffset;		}		/** Returns the width offset of the TextField with reference to the fieldWidth. */		public function get widthOffset():int		{			return _widthOffset;		}		/** Returns the height offset of the TextField with reference to the fieldHeight. */		public function get heightOffset():int		{			return _heightOffset;		}		/** Returns the horizontal lock method. */		public function get horizontalLock():String		{			return _horizontalLock;		}		/** Returns the horizontal lock method. */		public function get verticalLock():String		{			return _verticalLock;		}		/** Returns the left pad. */		public function get padding():int		{			return _leftPad;		}		/** Returns the top pad. */		public function get verticalPad():int		{			return _topPad;		}		/** Returns the left pad. */		public function get horizontalPad():int		{			return _leftPad;		}		/** Returns the left padding. */		public function get leftPad():int		{			return _leftPad;		}		/** Returns the right padding. */		public function get rightPad():int		{			return _rightPad;		}		/** Returns the top padding. */		public function get topPad():int		{			return _topPad;		}		/** Returns the bottom padding. */		public function get bottomPad():int		{			return _bottomPad;		}		/** Returns whether or not the Fonts have been embedded in the TextBox instance. */		public function get embedFonts():Boolean		{			return _embedFonts;		}		/** Returns whether or not the TextField is selectable. */		public function get selectable():Boolean		{			return _selectable;		}		/** Returns whether the TextField.type is set to INPUT or DYNAMIC */		public function get input():Boolean		{			return _input;		}		/** Returns whether or not the TextField is masked by the box excluding it's padding. */		public function get maskText():Boolean		{			return _maskText;		}		/** Returns whether or not the TextField has multiple lines of text. */		public function get multiLine():Boolean		{			return _multiLine;		}		/** Returns whether or not the text is wrapped within the TextField. */		public function get wordWrap():Boolean		{			return _wordWrap;		}		/** Returns the StyleSheet that the TextField is formatted by when set to HTML mode. */		public function get styleSheet():StyleSheet		{			return _styleSheet;		}		/** Returns the TextFormat that the TextField is formatted by when set to STANDARD mode. */		public function get textFormat():TextFormat		{			return _textFormat;			configDisplay();		}		/** Returns the currently stored htmlText. */		public function get htmlText():String		{			return _htmlText;		}		/** Returns the currently stored text. */		public function get text():String		{			return _standardText;		}		/** Returns whether or not the text is rendered using advanced anit-aliasing. */		public function get antiAlias():Boolean		{			return _antiAlias;		}		/** Returns the thickness of the rendered text. */		public function get thickness():int		{			return _thickness;		}		/** Returns the sharpness of the rendered text. */		public function get sharpness():int		{			return _sharpness;		}		/** Returns the Box Sprite. */		public function get box():Sprite		{			return _box;		}		/** Returns whether or not the box is displayed. */		public function get showBox():Boolean		{			return _showBox;		}		/** Returns the colour value of the box. */		public function get boxColour():int		{			return _boxColour;		}		/** Returns the alpha value of the box. */		public function get boxAlpha():Number		{			return _boxAlpha;		}		/** Returns whether or not the limits are displayed. */		public function get showLimits():Boolean		{			return _showLimits;		}		/** Returns the width of the limits visual aid. */		public function get limitsWidth():int		{			return _limitsWidth;		}		/** Returns the limits height. */		public function get limitsHeight():int		{			return _limitsHeight;		}		/** Returns the colour value of the limits. */		public function get limitsColour():int		{			return _limitsColour;		}		/** Returns the alpha value of the limits. */		public function get limitsAlpha():Number		{			return _limitsAlpha;		}		/** Returns the thickness of the limits visual aid. */		public function get limitsThickness():int		{			return _limitsThickness;		}		/** Returns the length of the limits visual aid. */		public function get limitsSize():int		{			return _limitsSize;		}		/** Returns the formatted text that is currently displayed inside the TextField. */		public function get formattedText():String		{			return _text.text;		}		/** Returns the TextField. */		public function get textField():TextField		{			return _text;		}		/** @param value Sets the width of the TextBox TextField. */		public override function set width(value:Number):void		{			fieldWidth = int(value);			configDisplay();		}		/** @param value Sets the height of the TextBox TextField. */		public override function set height(value:Number):void		{			fieldHeight = int(value);			configDisplay();		}	}}